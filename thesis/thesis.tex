\documentclass[a4paper,titlepage]{article}
\usepackage[a4paper, top=1in, left=1.2in, right=1.2in, bottom=1in, footskip=0.25in]{geometry}
\usepackage[absolute]{textpos}
\usepackage{subfigure}
\usepackage{float}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{blindtext}
\usepackage{array}
\usepackage{tabularx}
\usepackage{pgfplots}
\usepackage{pgf-umlcd}
\usepackage{tikz}
\usepackage{listings}
\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\lstset{basicstyle=\ttfamily}
\pgfplotsset{width=10cm,compat=1.9}
\graphicspath{ {./images/} }
\bibliographystyle{ieeetr}

% enum style and environment from
% https://github.com/jcb/these-jcb/blob/master/custom_pgf-umlcd.sty
% Author: Jean-Christophe Bach
\tikzstyle{umlcd style enum}=[rectangle split, rectangle split parts=2, 
every text node part/.style={text centered},
draw, minimum height=2em, umlcolor, minimum width=2cm, text width=4cm,
minimum height=1cm, node distance=2cm]
\newenvironment{enum}[3][]%
{
\begin{classAndInterfaceCommon}{#1}{#2}{#3}
}%
{\node[umlcd style enum, anchor=north] (\umlcdClassName) at (\umlcdClassPos)
    {$<<$enumeration$>>$ \\ \textbf{\umlcdClassName}
\nodepart{second}
\umlcdClassAttributes
};
\end{classAndInterfaceCommon}
}

\title{
	Currying the web: A Java REST framework - built on functional paradigms
	- compared to Spring Boot: Performance, developer guidance and ease of use
}
\author{Nico Lerchl\\2110257236\\[0.5cm]{\small Advisor: Dipl.-Ing. (FH) Bernhard Wallisch}}

\begin{document}

\begin{textblock}{15}(0.5, 0.5)
	\noindent\Large BACHELOR PAPER\\
	\large Thesis submitted in fulfillment of the requirements for the degree of Bachelor
	of Science in Engineering at the University of Applied Sciences Technikum Wien
	- Degree Program Computer Science
\end{textblock}

\maketitle

\newpage

\section*{Declaration}
“As author and creator of this work to hand, I confirm with my signature knowledge of the relevant
copyright regulations governed by higher education acts (see Urheberrechtsgesetz / Austrian
copyright law as amended as well as the Statute on Studies Act Provisions / Examination
Regulations of the UAS Technikum Wien as amended).\newline

\noindent I hereby declare that I completed the present work independently and that any ideas, whether
written by others or by myself, have been fully sourced and referenced. I am aware of any con-
sequences I may face on the part of the degree program director if there should be evidence of
missing autonomy and independence or evidence of any intent to fraudulently achieve a pass
mark for this work (see Statute on Studies Act Provisions / Examination Regulations of the UAS
Technikum Wien as amended).\newline

\noindent I further declare that up to this date I have not published the work to hand nor have I presented
it to another examination board in the same or similar form. I affirm that the version submitted
matches the version in the upload tool.“


\newpage
\section*{Kurzfassung}
\blindtext
\newline

\noindent Keywords: REST, Java, Funktionale Programmierung, Spring Boot


\newpage
\section*{Abstract}
\blindtext
\newline

\noindent Keywords: REST, Java, functional programming, Spring Boot

\newpage
\section*{Acknowledgements}
\blindtext

\newpage

\tableofcontents

\newpage

\section{Introduction}

Web development is a huge part of the software industry. Most of the time, the
server part of a web application is built using the MVC pattern and object
oriented programming \cite{damir2021architecture}. Functional programming is not
used as much in web development, in the last few years however, functional
programming has been gaining a lot of popularity with languages such as Haskell,
Scala and Clojure but also with functional concepts being added to object
oriented languages like Java and C\# \cite{klint2022functional}.\newline

\noindent Combining functional programming with web development using more
widely used languages e.g. Java is a scarcely researched topic which this thesis
aims to explore and shine some light on. The goal is to build a REST framework
using functional paradigms and compare it to Spring Boot in terms of
performance, developer guidance and ease of use.

\section{Literature review}
\subsection{REST}

Representational State Transfer (REST) is the state-of-the-art way to build the
server part of a client-server-architecture and it is most likely only going to
get bigger in the industry \cite{halili2018web}. It was first described by Roy
Fielding in his doctoral dissertation in 2000. REST is based on the following
properties \cite{fielding2000architectural}:

\begin{itemize}
	\item Client-server - The client and the server are separated and can be
	      developed independently.
	\item Stateless - The server does not store any client state. Every request
	      contains all the information the server needs to process it.
	\item Cache - Responses can be cached to improve performance.
	\item Uniform Interface - The interface between the client and the server is
	      uniform and simple.
\end{itemize}

\subsection{Functional programming}
\subsubsection{General}

Functional programming - unlike procedural or object oriented programming - is
not based on the Turing machine, but rather on lambda calculus. Lambda calculus,
developed by Alonzo Church in the 1930s, is a mathematical system later proven -
by Turing himself - to be equivalent to the Turing machine
\cite{turing1937computability}.\newline

\noindent The base principles of functional programming are
\cite{hughes1989functional}:
\begin{itemize}
	\item Immutability - Variables are not changed after they are assigned a
	      value.
	\item Pure functions - Functions do not have side effects and always return
	      the same output for the same input.
	\item Higher order functions - Functions can be passed as arguments to other
	      functions.
	\item Referential transparency - A function call can be replaced by its
	      return value without changing the program's behavior.
\end{itemize}

\noindent A big part of functional programmings is the concept of monads which
have their roots in category theory. They allow for encapsulating side effects
in a pure way. For a container to be a monad it has to abide by the laws of left
identity, right identity and associativity. \cite{wadler1992essence}

\subsubsection{Web development}

Yesod is a web framework for the before mentioned functional programming
language Haskell. It allows developers to build entire websites using templates
and widgets or RESTful web services. Additionally, Yesod offers the ability to
persist data using Haskell's type system into PostgreSQL, SQLite, MySQL, and
MongoDB. \cite{snoyman2015developing}

\subsubsection{In Java}

The introduction of lambda expressions in Java 8 brought functional programming
to the Java ecosystem. Where before developers had to use anonymous classes to
pass functions as arguments, they can now use lambda expressions. This also
shifts the view point of passing an object that carries functionality to passing
behavior itself. The concept behind these lambda expressions in Java is called
functional interfaces. Functional interfaces are interfaces that have exactly
one abstract method. They can be annotated with \verb|@FunctionalInterface|.
\newline

\noindent Also new to Java 8 is the Streams API. It hides away the iteration
over collections by offering many higher order functions. Additionally, streams
are only evaluated when a terminal operation, such as collecting, counting or
averaging is called, implementing the - before mentioned - functional
programming principle of lazy evaluation. \cite{warburton2014java}

Java 8 also saw the introduction of the \verb|Optional|-class. It is a container
that may or may not contain a non-null value. TODO

\subsection{Spring Boot}

Spring Boot is a framework for building stand-alone web applications and RESTful
web services in Java. Unlike Spring Framework there is zero requirement for XML
configuration. It can be deployed using an internal web server or going the
classic route of deploying a war file onto an external web server.
\cite{webb2013spring}

\section{Curryful}
Curryful tries to combine Java's simplicity with functional paradigms to build
better performant and unwanted behavior diminishing REST APIs, whilst offering
a great developer experience through easy use. As of now, when developing a REST
API using Curryful, one will require two dependencies: Curryful-commons and
curryful-rest. Having a dependency just for common functional programming tools
in Java allows for building any kind of application using functional paradigms
or enriching existing REST frameworks with functional utilities. Curryful is
hosted under a GitHub organization and can be found at
\url{https://github.com/Curryful}.

\subsection{Curryful-commons}
Curryful-commons offers a basis to writing functional Java code. It provides a
common abstract class for Monads and implementations for the Maybe and Try
monads. Since Java contains the before mentioned monadic Optional class, which
shares striking resemblance to the Maybe monad, the Maybe monad offers a
function to create a Maybe from an Optional. The Try monad allows for elegantly
handing exceptions in a functional way instead of throwing and catching them.

Though Java is always pass-by-value, anything but primitive types essentially
behave like pass-by-reference as object's references are passed by value.
\cite{hott2024java} This allows for objects to be mutated, without the caller
knowing, causing unwanted behavior and it also goes against the functional
principle of purity. To avoid this, curryful-commons offers mutable and
immutable variants of Java's \verb|ArrayList| and \verb|HashMap| where the
mutable collections inherit from the immutable ones. This way, the mutable ones
can be passed in place of their immutable counterparts, making it impossible for
the called function to mutate the parameters. This concept of "immutability
downcasts" is also referenced in "Javari: Adding Reference Immutability to Java"
\cite{tschantz2005javari} by Matthew S. Tschantz and Michael D. Ernst from the
University of Cambridge.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\begin{class}[text width=6cm]{ImmutableArrayList<T>}{0,0}
				\operation{+ empty() : ImmutableArrayList<T>}
				\operation{+ stream() : Stream<T>}
			\end{class}

			\begin{class}[text width=9cm]{MutableArrayList<T>}{0,-3}
				\inherit{ImmutableArrayList<T>}
				\operation{+ of(ImmutableArrayList<T>) : MutableArrayList<T>}
				\operation{+ add(T) : boolean}
				\operation{+ remove(T) : boolean}
			\end{class}
		\end{tikzpicture}
	\end{center}
	\caption{(Incomplete - for clarity) class diagrams of ImmutableArrayList and
		MutableArrayList and their relationship}
\end{figure}

\noindent Additionally, curryful-commons provides a higher order function
Y-combinator to allow for recursion when using lambda expressions. This is
necessary because Java does not allow referencing a lambda expression before it
has been fully defined, e.g. from within itself.

\begin{center}
	\begin{lstlisting}[language=Java, caption=Example of using the Y-combinator,
			captionpos=b]
		Y(readHttp).apply(ImmutableArrayList.empty());
	\end{lstlisting}
\end{center}

\subsection{Curryful-rest}
In curryful-rest, everywhere possible, lambda expressions are used to define
functionality. This is done in a way where each lambda expression only takes one
input. This allows for currying whenever desired.

\subsubsection{HTTP}
Curryful-rest implements its own HTTP handling to build functionally from the
ground up. The \verb|HTTP|-Class offers methods to parse incoming requests and
serialize outgoing responses. All fetching of information from the request such
as method, path, headers, etc. is done using regular expressions. As visible in
figure \ref{figure:http-context-classes} and \ref{figure:http-response-classes},
Headers, path and query parameters are stored in immutable collections to
mitigate unwanted behavior. All other types used do not allow for mutation as
their fields are \verb|final| and no mutating methods are provided.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\begin{class}[text width=10cm]{HttpContext}{0,0}
				\attribute{- actualUri : String}
				\attribute{- formalUri : String}
				\attribute{- pathParameters : ImmutableMaybeHashMap<String, String>}
				\attribute{- queryParamters : ImmutableMaybeHashMap<String, String>}
				\attribute{- headers : ImmutableMaybeHashMap<String, String>}
				\attribute{- address : InetAddress}
				\attribute{- body : Maybe<String>}
				\operation{+ getMethod() : HttpMethod}
				\operation{+ getActualUri() : String}
				\operation{+ getFormalUri() : String}
				\operation{+ getPathParameters() : ImmutableMaybeHashMap<String, String>}
				\operation{+ getQueryParameters() : ImmutableMaybeHashMap<String, String>}
				\operation{+ getHeaders() : ImmutableMaybeHashMap<String, String>}
				\operation{+ getAddress() : InetAddress}
				\operation{+ getBody() : Maybe<String>}
			\end{class}

			\begin{enum}[]{HttpMethod}{9,-1}
			\end{enum}

			\aggregation{HttpContext}{1}{}{HttpMethod}
		\end{tikzpicture}
	\end{center}
	\caption{(Incomplete - for clarity) class diagrams of classes representing
		HTTP requests in curryful-rest}
	\label{figure:http-context-classes}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\begin{class}[text width=10cm]{HttpResponse}{0,0}
				\attribute{- headers : ImmutableMaybeHashMap<String, String>}
				\attribute{- body : Maybe<String>}
				\operation{+ getCode() : HttpResponseCode}
				\operation{+ getHeaders() : ImmutableMaybeHashMap<String, String>}
				\operation{+ getContentType() : HttpContentType}
				\operation{+ getBody() : Maybe<String>}
			\end{class}

			\begin{enum}[]{HttpResponseCode}{-3,-5}
			\end{enum}

			\begin{enum}[]{HttpContentType}{3,-5}
			\end{enum}

			\aggregation{HttpResponse}{1}{}{HttpContentType}
			\aggregation{HttpResponse}{1}{}{HttpResponseCode}
		\end{tikzpicture}
	\end{center}
	\caption{(Incomplete - for clarity) class diagrams of classes representing
		HTTP responses in curryful-rest}
	\label{figure:http-response-classes}
\end{figure}

\subsubsection{Routing}
The \verb|Router|-Class provides one function that can be curried to register
middleware and endpoints. The curried function can then be called for each
connection and its raw HTTP. It is here where the \verb|HTTP|-Class' functions
are used. To find the formal endpoints for the actual endpoint, each registered
formal endpoint's URI is turned into a regular expression and the actual
endpoint's URI matched against, as well as checking if the endpoint' HTTP
methods match. A formal URI might looks like this: \verb|/hello/:name| where
\verb|hello| is a static part and \verb|:name| is a dynamic part in the form of
a path parameter. \verb|/hello/:name| then gets turned into
\verb|/hello/(?<name>[^/?]+)|. Query parameters are not part of the formal URI
and therefore removed from the actual URI before matching. If no formal endpoint
is found, a 404 response is sent. If a formal endpoint is found, the same regex
can be used to extract the path parameters, also the query parameters are
extracted and all other relevant data is stored in a \verb|HttpContext| object
to then be passed to the endpoint's rest function.
Figure \ref{figure:routing-classes} shows the classes used to register
endpoints, this will however be further explained - with code - later.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\begin{class}[text width=3cm]{Endpoint}{0,-1}
			\end{class}

			\begin{interface}[text width=4cm]{RestFunction}{5,0}
			\end{interface}

			\begin{class}[text width=3cm]{Destination}{5,-3}
				\attribute{- uri : String}
			\end{class}

			\begin{enum}[]{HttpMethod}{10,-3}
			\end{enum}

			\aggregation{Endpoint}{1}{}{RestFunction}
			\aggregation{Endpoint}{1}{}{Destination}
			\aggregation{Destination}{1}{}{HttpMethod}
		\end{tikzpicture}
	\end{center}
	\caption{(Incomplete - for clarity) class diagrams of classes representing
		HTTP requests in curryful-rest}
	\label{figure:routing-classes}
\end{figure}

\subsubsection{Middleware}
Middleware can be registered as \verb|PreMiddleware| or \verb|PostMiddleware|
where the former receives the same \verb|HttpContext| as the endpoint's rest
function and returns an \verb|HttpContext|, allowing for manipulation for
general use cases such as logging or authentication. The latter also receives
the \verb|HttpContext| but returns an \verb|HttpResponse|, allowing for the same
freedom of manipulating the response, returned by the endpoint's rest function,
as well as the \verb|HttpContext|.

\verb|PreMiddleware| is executed as soon as the \verb|HttpContext| can be
created, i.e. after finding the formal \verb|Destination| to be able to extract
the path parameters. \verb|PostMiddleware| is executed after the endpoint's rest
function has been called and returned an \verb|HttpResponse|.

\subsubsection{Server}
The \verb|Server|-Class provides the entry point to the REST application. This
is where a Socket is opened, connections accepted and then handed off to the
\verb|Router| to be processed. The \verb|Server| not only passes through the
Middleware created by the developer but also registers its own Middleware in
the form of a \verb|PreMiddleware| to log incoming requests and a
\verb|PostMiddleware| to log outgoing responses.\newline

\noindent Each new connection is accepted and handled in a new thread to provide
resilience against failure. If any errors were to occur during routing or the
executing of developer-implemented \verb|RestFunction|s, the server will respond
with a 500 status code but continue to accept new connections.

\section{Research questions and hypotheses}
\subsection{Research questions}

All of the following questions will be answered by comparing Curryful to Spring
Boot.

\begin{enumerate}
	\item Will building a REST API using functional paradigms, from the
	      ground up, result in a more performant application?
	\item Will building a REST API using functional paradigms naturally
	      guide the developer to eliminate unwanted behavior?
	\item Will the developer experience benefit from developing a REST API using
	      functional paradigms from the ground up?
\end{enumerate}

\subsection{Hypotheses}

\begin{enumerate}
	\item Building a REST API using functional paradigms, from the ground
	      up, will result in a more performant application. Functional
	      programming's keenness on mutability and mitigation of side effects
	      makes concurrency and parallelism disregard the need for locks or
	      synchronization. In the context of FaaS, startup times are lower
	      and the cold start problem is eased.
	\item Building a REST API using functional paradigms will naturally guide
	      the developer to eliminate unwanted behavior. Common pitfalls of
	      object oriented programming such as mutable state, side effects,
	      null references and unchecked exceptions will be avoided. Null
	      values are practically omitted and exceptions handled gracefully
	      through the use of monads. The stateless design functional
	      programming promotes will also synergize with REST's statelessness
	      principle.
	\item The developer experience will benefit as error handling becomes more
	      natural and testing becomes less of a burden because functions will
	      always produce the same output for the same input and not rely on
	      external factors. Additionally, the declarative nature of functional
	      programming will increase conciseness and expressiveness directly
	      leading to less lines required to achieve similar results.
\end{enumerate}

\section{Methodology}
ChatGPT 4 was prompted to generate two simple REST APIs. One for a todo list
application and one for playing Yahtzee. Each API was generated twice, once
using Curryful and once using Spring Boot. The prompts were kept as identical as
possible besides, having to provide more information about Curryful, as ChatGPT
does not know about this new framework, resulted in changes that had to be made.

The prompts, also found in the appendix, and any changes that had to
be done to the generated code are available in the projects' repositories:
\begin{itemize}
	\item \hyperlink{https://github.com/lerchl/curryful-bachelor-thesis-curryful-todo-list}{Todo list in Curryful}
	\item \hyperlink{https://github.com/lerchl/curryful-bachelor-thesis-spring-boot-todo-list}{Todo list in Spring Boot}
	\item \hyperlink{https://github.com/lerchl/curryful-bachelor-thesis-curryful-yahtzee}{Yahtzee in Curryful}
	\item \hyperlink{https://github.com/lerchl/curryful-bachelor-thesis-spring-boot-yahtzee}{Yahtzee in Spring Boot}
\end{itemize}

\subsection{Performance}
\subsubsection{Response time}
To measure response time, a folder or requests was sent to both todo list
applications with 100 iterations using Postman. From the results, the total
duration and average response time of both applications can be compared to
determine which application is more performant regarding response times. The
requests are:

\begin{itemize}
	\item GET all todos
	\item POST a todo
	\item GET the created todo
	\item PUT the created todo by changing the title
	\item POST the created todo to toggle completed
	\item DELETE the created todo
\end{itemize}

These requests can be found, in the form of JSON Postman collection v2.1
\hyperlink{https://github.com/lerchl/curryful-bachelor-thesis-postman-requests}{here}

\subsubsection{Cold start}
To measure cold start time, the todo list applications were each started 100
times using a bash script. As both Curryful and Spring Boot log their startup
time, it can be read by the script using regex and the average cold start time
calculated. The script can be found in the project repositories linked above and
also in the appendix.\newline

\noindent The scripts were run on two machines, to also get an understanding of
how different hardware affects the cold start time, if better hardware has a
bigger impact on the startup time on any of the two frameworks. A smaller
difference in startup time between the two machines would mean that the
framework does not require as much computational power to be performant.
The following table \ref{table:cold-start-machines} describes the machines used:

\begin{table}[h!]
	\begin{tabularx}{\textwidth}{|c|c|c|X|}
		\hline
		Alias   & CPU                 & Memory & OS                                      \\
		\hline
		Laptop  & AMD Ryzen 5 5600U   & 8GiB   & Ubuntu 23.10                            \\
		Desktop & Intel Core i9 9990K & 32GiB  & Ubuntu 20.04 through WSL2 on Windows 10 \\
		\hline
	\end{tabularx}
	\caption{
		Machines used to measure cold start time of the todo list applications
	}
	\label{table:cold-start-machines}
\end{table}

\noindent To calculate how much faster the application started on the desktop
compared to the laptop, this formula was used, where $t_{Laptop}$ is the average
Laptop and $t_{Desktop}$ the average Desktop cold start time:
$$
\frac{t_{Laptop} - t_{Desktop}}{t_{Laptop}} \times 100\%
$$

\subsection{Provoking unwanted behavior using invalid requests}
The prompts were held short and only ask for necessary implementation details,
leaving room to play with for the AI generating the code.\newline

\noindent Using Postman, both application generated by ChatGTP were sent
requests, trying to provoke unwanted behavior. The applications were restarted
after each request to empty the in-memory storage, which was one of the
implementation details. These requests can also be found, in the same format,
in the repository linked above.

\subsubsection{Todo list}
The requests trying to provoke unwanted behavior for the todo list applications
are:

\begin{table}[h!]
	\begin{tabularx}{\textwidth}{|X|X|c|c|}
		\hline
		HTTP-Method & URI               & Provocation                  & Expected status code \\
		\hline
		GET         & /unknown          & undefined endpoint           & 404                  \\
		POST        & /todos            & "completed" is a string      & 400                  \\
		POST        & /todos            & JSON of a car object         & 400                  \\
		POST        & /todos            & body is empty                & 400                  \\
		GET         & /todos/:id        & for id -1                    & 404                  \\
		PUT         & /todos/:id        & for id -1                    & 404                  \\
		POST        & /todos/:id/toggle & for id -1                    & 404                  \\
		DELETE      & /todos/:id        & for id -1                    & 404                  \\
		GET         & /todos/:id        & for id test                  & 400                  \\
		GET         & /todos/:id        & for id 999999999999999999999 & 400                  \\
		\hline
	\end{tabularx}
	\caption{
		Requests to provoke unwanted behavior for the todo list applications
	}
\end{table}

\subsubsection{Yahtzee}
The requests trying to provoke unwanted behavior for the Yahtzee applications
are:

\begin{table}[h!]
	\begin{tabularx}{\textwidth}{|X|X|c|c|}
		\hline
		HTTP-Method & URI      & Provocation                   	& Expected status code \\
		\hline
		GET         & /unknown & undefined endpoint            	& 404                  \\
		POST        & /login   & not registered		           	& 409                  \\
		POST        & /login   & missing credentials        	& 409                  \\
		GET         & /yahtzee & missing Authorization header	& 403                  \\
		GET         & /yahtzee & made-up Authorization header	& 403                  \\
		\hline
	\end{tabularx}
	\caption{
		Requests to provoke unwanted behavior for the Yahtzee applications
	}
\end{table}

\subsection{Static code analysis}
The generated code was analyzed using SonarCloud to determine both cyclomatic
and cognitive complexity. The cyclomatic complexity is a measure of the number
of linearly independent paths through a program's source code and therefore also
represents the number of test cases required to reach a coverage of 100\%.
Cognitive complexity describes how hard it is for a person to understand the
code. (TODO: Might need citation) \newline

\noindent An additional measure to determine developer experience is the number
of lines of code and statements, which Sonar also provides. To guarantee a fair
comparison, all projects were formatted according to the same rules:

\begin{itemize}
	\item lines must not be longer than 120 characters
	\item each added part of a method chain should be in a new line, unless
	      the entire chain is not longer than 120 characters
\end{itemize}

\section{Results}
\subsection{Performance}
\subsubsection{Response time}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				ybar,
				enlarge x limits=0.50,
				legend style={at={(0.5,-0.15)},
						anchor=north,legend columns=-1},
				ylabel={Response time (ms)},
				symbolic x coords={Curryful, Spring Boot},
				xtick=data,
				nodes near coords,
				nodes near coords align={vertical},
			]
			\addplot coordinates {(Curryful,4) (Spring Boot,3)};
		\end{axis}
	\end{tikzpicture}
	\caption{
		Average response time of the todo list applications
	}
\end{figure}

\subsubsection{Cold start}
\begin{table}[H]
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			Alias   & Curryful & Spring Boot \\
			\hline
			Laptop  & 238.14ms & 1.91s       \\
			Desktop & 199.50ms & 1.34s       \\
			\hline
		\end{tabular}
		\caption{Average cold start time of the todo list applications}
		\label{table:cold-start-results}
	\end{center}
\end{table}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				ybar,
				enlarge x limits=0.50,
				legend style={at={(0.5,-0.15)},
						anchor=north,legend columns=-1},
				ylabel={Cold start times (ms)},
				symbolic x coords={Curryful, Spring Boot},
				xtick=data,
				nodes near coords,
				nodes near coords align={vertical},
			]
			\addplot+[bar shift=-15pt] coordinates {(Curryful,238.14) (Spring Boot,1910)};
			\addplot+[bar shift=15pt] coordinates {(Curryful,199.50) (Spring Boot,1340)};
			\legend{Laptop, Desktop}
		\end{axis}
	\end{tikzpicture}
	\caption{Average cold start time of the todo list applications}
	\label{figure:cold-start-results}
\end{figure}

Using the formula mentioned under methodology to calculate how much faster the
application started on the desktop compared to the laptop, the following results
were obtained:

\begin{align*}
	\Delta_{\text{Curryful}} = \frac{238.14 - 199.50}{238.14} \times 100\% & = 16.23\% \\
	\Delta_{\text{Spring Boot}} = \frac{1.91 - 1.34}{1.91} \times 100\%    & = 29.84\%
\end{align*}

\noindent These two numbers mean that the Spring Boot application started
29.84\% faster on Desktop compared to Laptop, whereas the Curryful application
only started 16.23\% faster on Desktop compared to Laptop.

\subsection{Provoking unwanted behavior using invalid requests}
\subsubsection{Todo list}
\begin{table}[h!]
	\begin{tabularx}{\textwidth}{|X|c|c|c|}
		\hline
		\textbf{Request}                           & Expected status code & \multicolumn{2}{c|}{Actual status code}               \\
		                                           &                      & Curryful                                & Spring Boot \\
		\hline
		POST request where "completed" is a string & 400                  & 400                                     & 400         \\
		POST request where a car is added          & 400                  & 400                                     & 200         \\
		POST request where the body is empty       & 400                  & 400                                     & 400         \\
		GET request for id -1                      & 404                  & 404                                     & 200         \\
		PUT request for id -1                      & 404                  & 404                                     & 200         \\
		POST request to toggle completed for id -1 & 404                  & 404                                     & 200         \\
		DELETE request for id -1                   & 404                  & 404                                     & 200         \\
		GET request for id test                    & 400                  & -                                       & 400         \\
		GET request for id 999999999999999999999   & 400                  & -                                       & 400         \\
		\hline
	\end{tabularx}
	\caption{
		Results of requests trying to provoke unwanted behavior for the todo
		list applications
	}
\end{table}

\noindent The project using Curryful responded with the expected status code
seven out of nine times. The two times it did not respond with the expected
status code, the application crashed and did not respond at all. This is an
oversight by ChatGTP which tried parsing the id path parameter to an integer,
without checking if it is actually an integer. The generated code is shown by
listing \ref{lst:curryful-parse-error}:\newline

\begin{lstlisting}[language=Java, caption=ChatGPT generated code parsing to int
		without precaution, captionpos=b, label=lst:curryful-parse-error]
context.getPathParameters().get("id").map(Integer::parseInt)
\end{lstlisting}

\noindent More than just an oversight by ChatGPT, this is a massive error in the
Curryful framework itself.
\newline

\noindent The project using Spring Boot responded with the expected status code
four out of nine times. The POST request adding a car created a todo without a
title. All requests trying to access a non-existent todo with the id -1,
returned 200, making it seem like the todo actually exists.

\subsubsection{Yahtzee}
\begin{table}[h!]
	\begin{tabularx}{\textwidth}{|X|c|c|c|}
		\hline
		\textbf{Request}                           & Expected status code & \multicolumn{2}{c|}{Actual status code}               \\
		                                           &                      & Curryful                                & Spring Boot \\
		\hline
		POST request where "completed" is a string & 400                  & 400                                     & 400         \\
		POST request where a car is added          & 400                  & 400                                     & 200         \\
		POST request where the body is empty       & 400                  & 400                                     & 400         \\
		GET request for id -1                      & 404                  & 404                                     & 200         \\
		PUT request for id -1                      & 404                  & 404                                     & 200         \\
		POST request to toggle completed for id -1 & 404                  & 404                                     & 200         \\
		DELETE request for id -1                   & 404                  & 404                                     & 200         \\
		GET request for id test                    & 400                  & -                                       & 400         \\
		GET request for id 999999999999999999999   & 400                  & -                                       & 400         \\
		\hline
	\end{tabularx}
	\caption{
		Results of requests trying to provoke unwanted behavior for the Yahtzee
		applications
	}
\end{table}

\subsection{Static code analysis}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				ybar,
				enlarge x limits=0.50,
				legend style={at={(0.5,-0.15)},
						anchor=north,legend columns=-1},
				ylabel={Cyclomatic complexity},
				symbolic x coords={Curryful, Spring Boot},
				xtick=data,
				nodes near coords,
				nodes near coords align={vertical},
			]
			\addplot coordinates {(Curryful,31) (Spring Boot,22)};
			\addplot coordinates {(Curryful,45) (Spring Boot,45)};
			\legend{todo list, Yahtzee}
		\end{axis}
	\end{tikzpicture}
	\caption{Cyclomatic complexity of the applications}
	\label{figure:cyclomatic-complexity}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
				ybar,
				enlarge x limits=0.50,
				legend style={at={(0.5,-0.15)},
						anchor=north,legend columns=-1},
				ylabel={Cognitive complexity},
				symbolic x coords={Curryful, Spring Boot},
				xtick=data,
				nodes near coords,
				nodes near coords align={vertical},
			]
			\addplot coordinates {(Curryful,3) (Spring Boot,1)};
			\addplot coordinates {(Curryful,4) (Spring Boot,4)};
			\legend{todo list, Yahtzee}
		\end{axis}
	\end{tikzpicture}
	\caption{Cognitive complexity of the applications}
	\label{figure:cognitive-complexity}
\end{figure}

\section{Discussion}
\subsection{Performance}

\subsection{Provoking unwanted behavior using invalid requests}

\subsection{Static code analysis}

\section{Conclusion}

\section{Future work}
Since the scope of developing Curryful was limited to this thesis there are many
things that could be improved or added to the framework. This potential future
work will be summarized in this section.

\subsection{HTTP status code 405: Method not allowed}
Currently, if a request is made to an endpoint with a method that is not allowed
by the endpoint, the application will respond with a 404 status code. RFC 9110
states: "The 405 (Method Not Allowed) status code indicates that the method
received in the request-line is known by the origin server but not supported by
he target resource. The origin server MUST generate an Allow header field in a
405 response containing a list of the target resource's currently supported
methods." \cite{fielding2022rfc}

Implementing this status code, as well as caching the responses, also mentioned
in RFC 9110, would be a great addition to the framework.

\subsection{JSON (de-)serialization}
As seen in the todo list project generated by ChatGPT, Curryful does not handle
de- or serialization of JSON, so the prompt advised to use Jackson. Jackson was
not implemented based on functional paradigms and therefore had ChatGPT catch
exceptions, see listing \ref{lst:json-de-serialize}.\newline

\begin{lstlisting}[language=Java, caption=ChatGPT generated code to
		(de-)serialize JSON, captionpos=b, label=lst:json-de-serialize]
private static String serialize(Object obj) {
	try {
		return objectMapper.writeValueAsString(obj);
	} catch (Exception e) {
		throw new RuntimeException(e);
	}
}

private static <T> Maybe<T> deserialize(String content, Class<T> valueType) {
	try {
		return Maybe.just(objectMapper.readValue(content, valueType));
	} catch (Exception e) {
		return Maybe.none();
	}
}
\end{lstlisting}

\noindent This makes the programmer write more code, making the application more
verbose and also drags the developer back into the imperative programming
paradigms. Implementing a JSON (de-)serialization library based on functional
paradigms would be a great addition to the framework or even Curryful ecosystem.

\subsection{ORM}
Curryful does not provide any way to interact with a database. Implementing ORM
- or just a library to be able to connect to a database to run queries - using
the concepts of functional programming would allow for a more complete
framework.

\subsection{Maven compilation plugin}
"If a \{pick a functional programming language\} program compiles, it probably
works" is a common saying in the functional programming community. To bring this
saying to Curryful, a Maven plugin could be implemented to analyze the source
code, similar to a linter. This plugin could check for common mistakes, e.g.
using null values, not catching runtime exceptions or not checking if a value
is present before trying to access it. A plugin like this would have had the
compilation fail for the todo list project, where ChatGPT tried parsing the id
path parameter to an integer without checking, if it is actually an integer or
catching the exception and wrapping it in a Try.\newline

\begin{lstlisting}[language=Java, caption=ChatGPT generated code that would have
		had compilation fail using the before conceptuailzed plugin,
		captionpos=b, label=lst:curryful-parse-error]
context.getPathParameters().get("id").map(Integer::parseInt)
\end{lstlisting}

\section{Self-review}

\newpage
\listoffigures

\newpage
\lstlistoflistings

\newpage
\listoftables

\newpage
\bibliography{ref}

\newpage
\appendix

\section{Prompts}
\subsection{Todo list}
\subsubsection{Curryful}
\begin{lstlisting}
I have provide you with:
- The curryful-commons library, which curryful-rest builds upon
- The curryful-rest library, which is a simple rest framework,
	leaving out the utility classes Http and Uri, you don't need
	to know about those
- An example application using curryful-rest

The framework utilizes the concepts of functional programming,
so use functional programming principles you know about as well as
the principles already applied in the example code.

I want you to write a simple rest api for a todo list.
The todo list should be stored in memory and should be accessible
through the following endpoints:

- GET /todos
- POST /todos
- GET /todos/:id
- PUT /todos/:id
- DELETE /todos/:id
- POST /todos/:id/toggle

A todo is described by the following json object:
{
	"id": 1,
	"title": "Buy milk",
	"completed": false
}

As you can see, the framework does not handle json on its own. Please
use Jackson to parse json to objects and objects to json.
\end{lstlisting}

\subsubsection{Spring Boot}
\begin{lstlisting}
I want you to write a simple rest api for a todo list using spring boot.
The todo list should be stored in memory and should be accessible
through the following endpoints:

- GET /todos
- POST /todos
- GET /todos/:id
- PUT /todos/:id
- DELETE /todos/:id
- POST /todos/:id/toggle

A todo is described by the following json object:
{
	"id": 1,
	"title": "Buy milk",
	"completed": false
}
\end{lstlisting}

\subsection{Yahtzee}
\subsubsection{Curryful}
\subsubsection{Spring Boot}

\section{Cold startup time measuring script}
\subsection{Curryful}
\begin{lstlisting}
#!/bin/bash

# Define the location of the Maven wrapper and the jar file
MVNW_PATH="./mvnw"
JAR_FILE="target/todo-0.0.1-SNAPSHOT.jar"
LOG_DIR="target"
LOG_FILE="${LOG_DIR}/log.txt"

# Ensure Maven wrapper is executable
chmod +x $MVNW_PATH

# Build the project
$MVNW_PATH clean package

# Array to hold all the start times
declare -a startTimes

# Loop to start the application 100 times
for i in {1..100}
do
	echo "Iteration $i"

	# Start the application in the background and redirect output to log file
	java -jar $JAR_FILE > $LOG_FILE 2>&1 &
	PID=$!

	# Wait for a few seconds to let the application initialize
	sleep 0.5

	# Kill the application
	kill $PID
	wait $PID

	# Read the last line from the log file
	lastLine=$(tail -1 $LOG_FILE)
	REGEX="Curryful server started in (.*)ms"

	# Check if the line matches the expected startup message
	if [[ $lastLine =~ $REGEX ]]; then
		startTimes+=(${BASH_REMATCH[1]})
	else
		echo "Failed to extract start time in iteration $i"
	fi

	# Clear the log file to avoid confusion in the next iteration
	> $LOG_FILE
done

# Calculate the average start time
total=0
count=${#startTimes[@]}

for time in "${startTimes[@]}"
do
	total=$(echo "$total + $time" | bc)
done

if [ $count -gt 0 ]; then
	average=$(echo "scale=2; $total / $count" | bc)
	echo "Average cold start time: $average ms"
else
	echo "No valid start times recorded."
fi
\end{lstlisting}

\subsubsection{Spring Boot}
\begin{lstlisting}
#!/bin/bash

# Define the location of the Maven wrapper and the jar file
MVNW_PATH="./mvnw"
JAR_FILE="target/todo-0.0.1-SNAPSHOT.jar"
LOG_DIR="target"
LOG_FILE="${LOG_DIR}/log.txt"

# Ensure Maven wrapper is executable
chmod +x $MVNW_PATH

# Build the project
$MVNW_PATH clean package

# Array to hold all the start times
declare -a startTimes

# Loop to start the application 100 times
for i in {1..100}
do
	echo "Iteration $i"

	# Start the application in the background and redirect output to log file
	java -jar $JAR_FILE > $LOG_FILE 2>&1 &
	PID=$!

	# Wait for a few seconds to let the application initialize
	sleep 5

	# Kill the application
	kill $PID
	wait $PID

	# Read the last line from the log file
	lastLine=$(tail -1 $LOG_FILE)
	REGEX="Started Application in (.*) seconds"

	# Check if the line matches the expected startup message
	if [[ $lastLine =~ $REGEX ]]; then
		startTimes+=(${BASH_REMATCH[1]})
	else
		echo "Failed to extract start time in iteration $i"
	fi

	# Clear the log file to avoid confusion in the next iteration
	> $LOG_FILE
done

# Calculate the average start time
total=0
count=${#startTimes[@]}

for time in "${startTimes[@]}"
do
	total=$(echo "$total + $time" | bc)
done

if [ $count -gt 0 ]; then
	average=$(echo "scale=2; $total / $count" | bc)
	echo "Average cold start time: $average seconds"
else
	echo "No valid start times recorded."
fi
\end{lstlisting}

\end{document}
